/**
 * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/dhlab-org/msw-auto-mock)
 * Feel free to commit/edit it as you need.
 */
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck

import { selectResponseByScenario } from '@dhlab/msw-auto-mock';
import { faker } from '@faker-js/faker';
import { bypass, HttpResponse, http, passthrough } from 'msw';
import { scenarios } from '../scenarios';

faker.seed(1);

const baseURL = 'https://example.com/api/v1';
const MAX_ARRAY_LENGTH = 20;

export const postsHandlers = [
  http.get(`${baseURL}/posts`, async (info) => {
    const isBypass = info.request.headers.get('x-bypass') === 'true';

    if (isBypass) {
      try {
        const originalResponse = await fetch(bypass(info.request));
        if (originalResponse.status !== 404) {
          return passthrough();
        }
      } catch (error) {
        console.warn('[MSW] Bypass 실패, mock 데이터 사용:', error);
      }
    }

    const resultArray = [
      {
        status: 200,
        responseType: 'application/json',
        body: JSON.stringify(await getGetPosts200Response(info)),
      },
    ];
    const selectedResult = selectResponseByScenario('get', '/posts', resultArray, info, scenarios);

    return new HttpResponse(selectedResult.body, {
      status: selectedResult.status,
      headers: selectedResult.responseType
        ? {
            'Content-Type': selectedResult.responseType,
          }
        : undefined,
    });
  }),

  http.post(`${baseURL}/posts`, async (info) => {
    const isBypass = info.request.headers.get('x-bypass') === 'true';

    if (isBypass) {
      try {
        const originalResponse = await fetch(bypass(info.request));
        if (originalResponse.status !== 404) {
          return passthrough();
        }
      } catch (error) {
        console.warn('[MSW] Bypass 실패, mock 데이터 사용:', error);
      }
    }

    const resultArray = [
      {
        status: 201,
        responseType: 'application/json',
        body: JSON.stringify(await getCreatePost201Response(info)),
      },
      {
        status: 400,
        responseType: undefined,
        body: undefined,
      },
    ];
    const selectedResult = selectResponseByScenario('post', '/posts', resultArray, info, scenarios);

    return new HttpResponse(selectedResult.body, {
      status: selectedResult.status,
      headers: selectedResult.responseType
        ? {
            'Content-Type': selectedResult.responseType,
          }
        : undefined,
    });
  }),

  http.get(`${baseURL}/posts/:id`, async (info) => {
    const isBypass = info.request.headers.get('x-bypass') === 'true';

    if (isBypass) {
      try {
        const originalResponse = await fetch(bypass(info.request));
        if (originalResponse.status !== 404) {
          return passthrough();
        }
      } catch (error) {
        console.warn('[MSW] Bypass 실패, mock 데이터 사용:', error);
      }
    }

    const resultArray = [
      {
        status: 200,
        responseType: 'application/json',
        body: JSON.stringify(await getGetPostById200Response(info)),
      },
      {
        status: 404,
        responseType: undefined,
        body: undefined,
      },
    ];
    const selectedResult = selectResponseByScenario('get', '/posts/:id', resultArray, info, scenarios);

    return new HttpResponse(selectedResult.body, {
      status: selectedResult.status,
      headers: selectedResult.responseType
        ? {
            'Content-Type': selectedResult.responseType,
          }
        : undefined,
    });
  }),

  http.put(`${baseURL}/posts/:id`, async (info) => {
    const isBypass = info.request.headers.get('x-bypass') === 'true';

    if (isBypass) {
      try {
        const originalResponse = await fetch(bypass(info.request));
        if (originalResponse.status !== 404) {
          return passthrough();
        }
      } catch (error) {
        console.warn('[MSW] Bypass 실패, mock 데이터 사용:', error);
      }
    }

    const resultArray = [
      {
        status: 200,
        responseType: 'application/json',
        body: JSON.stringify(await getUpdatePost200Response(info)),
      },
      {
        status: 404,
        responseType: undefined,
        body: undefined,
      },
    ];
    const selectedResult = selectResponseByScenario('put', '/posts/:id', resultArray, info, scenarios);

    return new HttpResponse(selectedResult.body, {
      status: selectedResult.status,
      headers: selectedResult.responseType
        ? {
            'Content-Type': selectedResult.responseType,
          }
        : undefined,
    });
  }),

  http.delete(`${baseURL}/posts/:id`, async (info) => {
    const isBypass = info.request.headers.get('x-bypass') === 'true';

    if (isBypass) {
      try {
        const originalResponse = await fetch(bypass(info.request));
        if (originalResponse.status !== 404) {
          return passthrough();
        }
      } catch (error) {
        console.warn('[MSW] Bypass 실패, mock 데이터 사용:', error);
      }
    }

    const resultArray = [
      {
        status: 204,
        responseType: undefined,
        body: undefined,
      },
      {
        status: 404,
        responseType: undefined,
        body: undefined,
      },
    ];
    const selectedResult = selectResponseByScenario('delete', '/posts/:id', resultArray, info, scenarios);

    return new HttpResponse(selectedResult.body, {
      status: selectedResult.status,
      headers: selectedResult.responseType
        ? {
            'Content-Type': selectedResult.responseType,
          }
        : undefined,
    });
  }),

  http.get(`${baseURL}/posts/:postId/comments`, async (info) => {
    const isBypass = info.request.headers.get('x-bypass') === 'true';

    if (isBypass) {
      try {
        const originalResponse = await fetch(bypass(info.request));
        if (originalResponse.status !== 404) {
          return passthrough();
        }
      } catch (error) {
        console.warn('[MSW] Bypass 실패, mock 데이터 사용:', error);
      }
    }

    const resultArray = [
      {
        status: 200,
        responseType: 'application/json',
        body: JSON.stringify(await getGetPostComments200Response(info)),
      },
    ];
    const selectedResult = selectResponseByScenario('get', '/posts/:postId/comments', resultArray, info, scenarios);

    return new HttpResponse(selectedResult.body, {
      status: selectedResult.status,
      headers: selectedResult.responseType
        ? {
            'Content-Type': selectedResult.responseType,
          }
        : undefined,
    });
  }),

  http.post(`${baseURL}/posts/:postId/comments`, async (info) => {
    const isBypass = info.request.headers.get('x-bypass') === 'true';

    if (isBypass) {
      try {
        const originalResponse = await fetch(bypass(info.request));
        if (originalResponse.status !== 404) {
          return passthrough();
        }
      } catch (error) {
        console.warn('[MSW] Bypass 실패, mock 데이터 사용:', error);
      }
    }

    const resultArray = [
      {
        status: 201,
        responseType: 'application/json',
        body: JSON.stringify(await getCreateComment201Response(info)),
      },
      {
        status: 404,
        responseType: undefined,
        body: undefined,
      },
    ];
    const selectedResult = selectResponseByScenario('post', '/posts/:postId/comments', resultArray, info, scenarios);

    return new HttpResponse(selectedResult.body, {
      status: selectedResult.status,
      headers: selectedResult.responseType
        ? {
            'Content-Type': selectedResult.responseType,
          }
        : undefined,
    });
  }),
];

export function getGetPosts200Response(info: any) {
  const url = new URL(info.request.url);
  const page = parseInt(url.searchParams.get('page') || '1');
  const limit = parseInt(url.searchParams.get('limit') || '10');

  const totalItems = 25; // 전체 게시글 수
  const totalPages = Math.ceil(totalItems / limit);

  return {
    items: [...new Array(Math.min(limit, totalItems - (page - 1) * limit)).keys()].map(() => ({
      id: faker.string.uuid(),
      title: faker.lorem.sentence({ min: 3, max: 8 }),
      content: faker.lorem.paragraphs({ min: 2, max: 4 }),
      userId: faker.string.uuid(),
      author: {
        id: faker.string.uuid(),
        username: faker.person.fullName(),
        email: faker.internet.email(),
        createdAt: faker.date.past(),
      },
      status: faker.helpers.arrayElement(['DRAFT', 'PUBLISHED']),
      tags: [...new Array(faker.number.int({ min: 1, max: 3 })).keys()].map((_) => faker.lorem.word()),
      createdAt: faker.date.past(),
      updatedAt: faker.date.past(),
    })),
    total: totalItems,
    page: page,
    totalPages: totalPages,
  };
}

export function getCreatePost201Response() {
  return {
    id: faker.string.uuid(),
    title: faker.lorem.words(),
    content: faker.lorem.words(),
    userId: faker.string.uuid(),
    author: {
      id: faker.string.uuid(),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      createdAt: faker.date.past(),
    },
    status: faker.helpers.arrayElement(['DRAFT', 'PUBLISHED']),
    tags: [...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys()].map((_) => faker.lorem.words()),
    createdAt: faker.date.past(),
    updatedAt: faker.date.past(),
  };
}

export function getGetPostById200Response() {
  return {
    id: faker.string.uuid(),
    title: faker.lorem.words(),
    content: faker.lorem.words(),
    userId: faker.string.uuid(),
    author: {
      id: faker.string.uuid(),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      createdAt: faker.date.past(),
    },
    status: faker.helpers.arrayElement(['DRAFT', 'PUBLISHED']),
    tags: [...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys()].map((_) => faker.lorem.words()),
    createdAt: faker.date.past(),
    updatedAt: faker.date.past(),
  };
}

export function getUpdatePost200Response() {
  return {
    id: faker.string.uuid(),
    title: faker.lorem.words(),
    content: faker.lorem.words(),
    userId: faker.string.uuid(),
    author: {
      id: faker.string.uuid(),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      createdAt: faker.date.past(),
    },
    status: faker.helpers.arrayElement(['DRAFT', 'PUBLISHED']),
    tags: [...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys()].map((_) => faker.lorem.words()),
    createdAt: faker.date.past(),
    updatedAt: faker.date.past(),
  };
}

export function getGetPostComments200Response() {
  return [...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys()].map((_) => ({
    id: faker.string.uuid(),
    content: faker.lorem.words(),
    userId: faker.string.uuid(),
    postId: faker.string.uuid(),
    author: {
      id: faker.string.uuid(),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      createdAt: faker.date.past(),
    },
    createdAt: faker.date.past(),
    updatedAt: faker.date.past(),
  }));
}

export function getCreateComment201Response() {
  return {
    id: faker.string.uuid(),
    content: faker.lorem.words(),
    userId: faker.string.uuid(),
    postId: faker.string.uuid(),
    author: {
      id: faker.string.uuid(),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      createdAt: faker.date.past(),
    },
    createdAt: faker.date.past(),
    updatedAt: faker.date.past(),
  };
}
